;***************************************************************************
; SUBRUTINA DE LECTURA DE TEMPERATURA CON MAX6675 Y TERMOCUPLA TIPO K.
; DEVUELVE EL VALOR DE TEMPERATURA EN BINARIO (16 BITS) DE 0 A 1024°C
; O DEVUELVE EL VALOR DE TEMPERATURA EN FORMATO BCD (4 CIFRAS) DE 0 A 1024°C
; VERSION 1.0
; 
; REALIZADA POR ING. C.N. JOSUE NORBERTO MARTINEZ F. (SEPT. 2021)
;				produccionesrek@gmail.com
;				http://prdiagramasyelectronica.blogspot.com/
;
;***************************************************************************
; DESCRIPCION:
;
; EL CODIGO DE ESTA SUBRUTINA PUEDE SER AGREGADO AL CODIGO DEL PROGRAMA 
; PRINCIPAL O PUEDE SER INCLUIDO UTILIZANDO EL COMANDO ".INCLUDE"
;
;		EJEMPLO:
;		.INCLUDE "SUBRUTINA_MAX6675.INC"
;
;
; PARA EJECUTAR ESTA SUBRUTINA SE DEBEN SEGUIR LOS SIGUIENTES PASOS:
;
;	1.-	DEFINIR CONSTANTES Y REGISTROS DE LA SUBRUTINA
;	2.-	INICIALIZAR LA SUBRUTINA					
;	3.-	UTILIZAR EL COMANDO "RCALL" PARA EJECUTAR LA SUB-RUTINA
;	4.- LEER EL VALOR ACTUALIZADO DE TEMPERATURA
;
; ** NOTAS **:
;
;	*PUEDE SELECCIONAR EL FORMATO DE SALIDA DEL VALOR DE TEMPERATURA
;	 A TRAVES DE LA CONSTANTE "MAX_SALIDA_BCD" (0 = BINARIO; 1 = BCD)
;
;	*NO ES NECESARIO CONFIGURAR EL PUERTO DDRX DEL MAX6675, 
;	 YA QUE SE REALIZA DE FORMA AUTOMÁTICA DENTRO DE LA SUBRUTINA.
;
;	*NO UTILIZAR R13, R14, R15, R16, R17, R18, R19 ni R20 PARA DEFINIR LOS REGISTROS: 
;	 "TEMP_MAX6675_LOW", NI "TEMP_MAX6675_HIGH"
;
;	*LA CONSTANTE "MAX6675_FREC_AVR" DEBE SER UN VALOR ENTERO IGUAL O MAYOR A 1
;
;	*ESTA SUBRUTINA MODIFICA LOS REGISTROS R16 Y R17 DURANTE SU OPERACION
;
;---------------------------------------------------------------------
;--------------------- EJEMPLO DE IMPLEMENTACION:---------------------
;---------------------------------------------------------------------
/*

; DEFINICION DE REGISTROS Y CONSTANTES DE LA SUBRUTINA MAX6675 
; (*** NO UTILIZAR LOS REGISTROS R13, R14, R15, R16, R17, R18, R19 ni R20 ***)

		.DEF TEMP_MAX6675_LOW	= R21	;SI "MAX_SALIDA_BCD = 0" VALOR DE TEMPERATURA LEIDO (BYTE 1)
										;SI "MAX_SALIDA_BCD = 1" VALOR DE TEMPERATURA LEIDO (DECENAS Y UNIDADES)
		.DEF TEMP_MAX6675_HIGH	= R22	;SI "MAX_SALIDA_BCD = 0" VALOR DE TEMPERATURA LEIDO (BYTE 2)
										;SI "MAX_SALIDA_BCD = 1" VALOR DE TEMPERATURA LEIDO (MILLARES Y CENTENAS)

		.EQU PORTX_MAX6675		= PORTD ;SELECCIONAR EL PUERTO EN EL QUE SE ENCUENTRA CONECTADO EL MAX6675
		.EQU MAX6675_CLK		= PD0	;SELECCIONAR EL PIN DEL PUERTO EN QUE SE ENCUENTRA CONECTADO "CLK"
		.EQU MAX6675_CS			= PD1	;SELECCIONAR EL PIN DEL PUERTO EN QUE SE ENCUENTRA CONECTADO "CS"
		.EQU MAX6675_DO			= PD2	;SELECCIONAR EL PIN DEL PUERTO EN QUE SE ENCUENTRA CONECTADO "DO"
		.EQU MAX6675_FREC_AVR	= 4		;FRECUENCIA DE OPERACION DEL MICROCONTROLADOR (VALOR MINIMO = 1)
		.EQU MAX_SALIDA_BCD		= 1		;0 = VALOR DE TEMPERATURA EN BINARIO (16 BITS)
										;1 = VALOR DE TEMPERATURA EN BCD (4 CIFRAS EN 2 REGISTROS)

; INICIALIZA LA SUBRUTINA PARA LECTURA DEL MAX6675
; (EJECUTAR UNA SOLA VEZ AL INICIO DEL PROGRAMA)
		RCALL INICIALIZA_MAX6675
	
; LEE TEMPERATURA DEL SENSOR
; (LA TEMPERATURA LEIDA SE ALMACENA EN LOS REGISTROS TEMP_MAX6675_HIGH Y TEMP_MAX6675_LOW)
		RCALL LEER_MAX6675

; BUCLE FINAL
		FIN:
		RJMP FIN

;INCLUYE ARCHIVO DE LA SUBRUTINA
		.INCLUDE "SUBRUTINA_MAX6675.INC"

*/
;---------------------------------------------------------------------
;------------------------- TERMINA EJEMPLO:---------------------------
;---------------------------------------------------------------------

;***************************************************************************
;CODIGO

;MAX6675_DIVISION_16_VS_16_BITS
	.DEF	M6675_RESIDUO_16L		=	R14		;RESIDUO LOW (REGISTRO BAJO: DE R0 A R15)
	.DEF	M6675_RESIDUO_16H		=	R15		;RESIDUO HIGH (REGISTRO BAJO: DE R0 A R15)
	.DEF	M6675_RESULTADO_16L		=	R16		;RESULTADO LOW (MISMO REGISTRO QUE EL DIVIDENDO)
	.DEF	M6675_RESULTADO_16H		=	R17		;RESULTADO HIGH (MISMO REGISTRO QUE EL DIVIDENDO)
	.DEF	M6675_DIVIDENDO_16L		=	R16		;DIVIDENDO LOW (MISMO REGISTRO QUE EL RESULTADO)
	.DEF	M6675_DIVIDENDO_16H		=	R17		;DIVIDENDO HIGH (MISMO REGISTRO QUE EL RESULTADO)
	.DEF	M6675_DIVISOR_16L		=	R18		;DIVISOR LOW
	.DEF	M6675_DIVISOR_16H		=	R19		;DIVISOR HIGH
	.DEF	M6675_CONTADORDIV_16	=	R20		;CONTADOR DE LA SUBRUTINA

;MAX6675_BINARIO_A_BCD
	.DEF	M6675_RESULT_BCD_1		=R13	;Resultado BCD, digitos 1 y 0 (no modificar R13)
	.DEF	M6675_RESULT_BCD_2		=R14	;Resultado BCD, digitos 3 y 2 (no modificar R14)
	.DEF	M6675_RESULT_BCD_DUMMY	=R15	;Resultado BCD, digito 4 (no modificar R15)
	.DEF	M6675_CONTADOR_BIN_BCD		=R16	;Contador auxiliar
	.DEF	M6675_AUXILIAR_BIN_BCD		=R17	;Registro auxiliar

;ADVERTENCIAS PARA EL COMPILADOR
		
		.IF MAX6675_FREC_AVR < 1
		.ERROR " *MAX6675_FREC_AVR* Debe ser igual o mayor a 1 MHZ "
		.ENDIF

		.IF MAX_SALIDA_BCD < 0
		.ERROR " *MAX_SALIDA_BCD* Debe ser 0 para salida en binario o 1 para salida en BCD "
		.ENDIF

		.IF MAX_SALIDA_BCD > 1
		.ERROR " *MAX_SALIDA_BCD* Debe ser 0 para salida en binario o 1 para salida en BCD "
		.ENDIF


INICIALIZA_MAX6675:

		;CONFIGURACION DDRX
		;CLK = SALIDA
		;CS = SALIDA
		;DO = ENTRADA
				SBI (PORTX_MAX6675 - 1), MAX6675_CLK
				SBI (PORTX_MAX6675 - 1), MAX6675_CS
				CBI (PORTX_MAX6675 - 1), MAX6675_DO

		;MAX6675 DESACTIVADO	MAX6675_CS  (CS negado)
				CBI PORTX_MAX6675, MAX6675_CLK
				SBI PORTX_MAX6675, MAX6675_CS

		;REESTABLECE REGISTROS TEMPERATURA
				CLR TEMP_MAX6675_LOW
				CLR TEMP_MAX6675_HIGH

RET


LEER_MAX6675:
/* Force CS low to output the first bit on the SO pin. A complete serial interface read requires 16 clock 
cycles. Read the 16 output bits on the falling edge of the clock. The first bit, D15, is a dummy sign bit 
and is always zero. Bits D14–D3 contain the converted temperature in the order of MSB to LSB. Bit D2 is 
normally low and goes high when the thermocouple input is open. D1 is low to provide a device ID for the 
MAX6675 and bit D0 is three-state. */

		;REESTABLECE REGISTROS TEMPERATURA
				CLR TEMP_MAX6675_LOW
				CLR TEMP_MAX6675_HIGH

		;ACTIVA CS (NEGADO) = 0
				CBI PORTX_MAX6675, MAX6675_CS
				RCALL DELAY_MAX6675	

		;CICLO LECTURA DE 16 BITS
				;REESTABLECE CONTADOR AUX R17
				CLR R17
		
				ST_LOOP1:
						RCALL M6675_LEE_DATO
						RCALL M6675_PULSO_CLK
						INC R17
						CPI R17, 16
						BRNE ST_LOOP1

		;DESACTIVA CS (NEGADO) = 1
				SBI PORTX_MAX6675, MAX6675_CS
				RCALL DELAY_MAX6675	

		;ELIMINA VALORES DUMMY
				LSR TEMP_MAX6675_HIGH
				ROR TEMP_MAX6675_LOW

				LSR TEMP_MAX6675_HIGH
				ROR TEMP_MAX6675_LOW
				
				LSR TEMP_MAX6675_HIGH
				ROR TEMP_MAX6675_LOW

		;COMPRUEBA TERMOCUPLA ABIERTA
				BRCS TERMOCUPLA_ABIERTA
				RJMP LM_CONTINUA1

				TERMOCUPLA_ABIERTA:
						CLR TEMP_MAX6675_HIGH
						CLR TEMP_MAX6675_LOW

				LM_CONTINUA1:
				ANDI TEMP_MAX6675_HIGH, 0b0000_1111

		;DIVDIDE VALOR ENTRE 4
		/* the 12-bit result onto the SO pin. A sequence of all
		zeros means the thermocouple reading is 0°C. A
		sequence of all ones means the thermocouple reading
		is +1023.75°C. */  
				
		;RESPALDA REGISTROS AUXILIARES DE DIVISION
				PUSH M6675_RESIDUO_16L		
				PUSH M6675_RESIDUO_16H		
				PUSH M6675_RESULTADO_16L	
				PUSH M6675_RESULTADO_16H
				PUSH M6675_DIVISOR_16L
				PUSH M6675_DIVISOR_16H
				PUSH M6675_CONTADORDIV_16

				MOV M6675_DIVIDENDO_16L, TEMP_MAX6675_LOW
				MOV M6675_DIVIDENDO_16H, TEMP_MAX6675_HIGH
				LDI M6675_DIVISOR_16L, 4
				LDI M6675_DIVISOR_16H, 0
				RCALL MAX6675_DIVISION_16_VS_16_BITS

				MOV TEMP_MAX6675_LOW, M6675_RESULTADO_16L
				MOV TEMP_MAX6675_HIGH, M6675_RESULTADO_16H

		;REESTABLECE REGISTROS AUXILIARES DE DIVISION
				POP M6675_CONTADORDIV_16
				POP M6675_DIVISOR_16H
				POP M6675_DIVISOR_16L
				POP M6675_RESULTADO_16H
				POP M6675_RESULTADO_16L
				POP M6675_RESIDUO_16H
				POP M6675_RESIDUO_16L		

		;COMPRUEBA FORMATO DE SALIDA DEL VALOR DE TEMPERATURA
				LDI R16, 1
				CPI R16, MAX_SALIDA_BCD
				BREQ TEMP_EN_FORMATO_BCD

RET


M6675_LEE_DATO:
		;LEE PRIMER BIT
				IN R16, (PORTX_MAX6675 - 2)
				SBRS R16, MAX6675_DO
				RJMP ST_DATO_CERO
		;DATO UNO
				SEC
				ROL TEMP_MAX6675_LOW
				ROL TEMP_MAX6675_HIGH

RET

		ST_DATO_CERO:
				LSL TEMP_MAX6675_LOW
				ROL TEMP_MAX6675_HIGH

RET



M6675_PULSO_CLK:

		;CLK HIGH
				SBI PORTX_MAX6675, MAX6675_CLK
				RCALL DELAY_MAX6675
		;CLK LOW
				CBI PORTX_MAX6675, MAX6675_CLK
				RCALL DELAY_MAX6675

RET


DELAY_MAX6675:
;APROX 5uS
		LDI R16, MAX6675_FREC_AVR
		DM6_LOOP1:
				DEC R16
				CPI R16,0
		BRNE DM6_LOOP1

RET


TEMP_EN_FORMATO_BCD:

		RCALL M6675_SUBRUTINA_CONVERT_BIN16_BCD
		MOV TEMP_MAX6675_LOW, M6675_RESULT_BCD_1
		MOV TEMP_MAX6675_HIGH, M6675_RESULT_BCD_2

RET


;***************************************************************************
;
; SUBRUTINA DE DIVISION DE UN NUMERO DE 16 BITS (ALOJADO EN DOS REGISTROS)
; ENTRE OTRO NUMERO DE 16 BITS (ALOJADO EN OTROS DOS REGISTROS), EN LENGUAJE 
; ENSAMBLADOR, COMPATIBLE PARA DIFERENTES FAMILIAS DE MICOCONTROLADORES AVR DE 8 BITS.
;
; REALIZADA POR ING. C.N. JOSUE NORBERTO MARTINEZ F. (ABRIL 2020)
;				produccionesrek@gmail.com
;				http://prdiagramasyelectronica.blogspot.com/
;				
;***************************************************************************

MAX6675_DIVISION_16_VS_16_BITS:
		CLR	M6675_RESIDUO_16L					;clear remainder Low byte
		SUB	M6675_RESIDUO_16H,M6675_RESIDUO_16H		;clear remainder High byte and carry
		LDI	M6675_CONTADORDIV_16,17			;init loop counter

M6675_D16U_1:	
		ROL	M6675_DIVIDENDO_16L				;shift left dividend
		ROL	M6675_DIVIDENDO_16H
		DEC	M6675_CONTADORDIV_16				;decrement counter
		BRNE	M6675_D16U_2					;if done
RET								;return

M6675_D16U_2:	
		ROL	M6675_RESIDUO_16L					;shift dividend into remainder
		ROL	M6675_RESIDUO_16H
		SUB	M6675_RESIDUO_16L,M6675_DIVISOR_16L		;remainder = remainder - divisor
		SBC	M6675_RESIDUO_16H,M6675_DIVISOR_16H		;
		BRCC	M6675_D16U_3					;if result negative
		ADD	M6675_RESIDUO_16L,M6675_DIVISOR_16L		;restore remainder
		ADC	M6675_RESIDUO_16H,M6675_DIVISOR_16H
		CLC								;clear carry to be shifted into result
		RJMP	M6675_D16U_1					;else

M6675_D16U_3:	
		SEC								;set carry to be shifted into result
		RJMP	M6675_D16U_1


;***************************************************************************
; "M6675_SUBRUTINA_CONVERT_BIN16_BCD" - Conversion de binario (16 bits) a BCD (Binary Coded
; Decimal)
;
; El código de esta subrutina fue extraido de la Application Note AVR204: BCD Arithmetics
; El algoritmo de funcionamiento se describe en ese mismo documento
;
; Adaptación de código por: Ing. Josue Norberto Martínez (ago-2020)
;							produccionesrek@gmail.com
;							http://prdiagramasyelectronica.blogspot.com/
;
;***************************************************************************

;***** Constantes de la subrutina (no modificar)

.EQU	M6675_DIRECCION_BCD_0	=13			;Direccion de M6675_RESULT_BCD_1
.EQU	M6675_DIRECCION_BCD_2	=15			;Direccion de M6675_RESULT_BCD_DUMMY

;***** Código

M6675_SUBRUTINA_CONVERT_BIN16_BCD:
	
	;RESPALDA VALORES DE ENTRADA Y REGISTROS AUXILIARES
	PUSH TEMP_MAX6675_LOW
	PUSH TEMP_MAX6675_HIGH
	PUSH M6675_CONTADOR_BIN_BCD
	PUSH M6675_AUXILIAR_BIN_BCD

	LDI	M6675_CONTADOR_BIN_BCD,16		;Inicia contador	
	CLR	M6675_RESULT_BCD_DUMMY			;borra registros (3 BYTES)
	CLR	M6675_RESULT_BCD_2		
	CLR	M6675_RESULT_BCD_1		
	CLR	ZH						;borra ZH 

M6675_BBCDX_1:

	LSL	TEMP_MAX6675_LOW			;Desplazamiento de bits del valor de entrada
	ROL	TEMP_MAX6675_HIGH			;a traves de todos los Bytes
	ROL	M6675_RESULT_BCD_1			;
	ROL	M6675_RESULT_BCD_2
	ROL	M6675_RESULT_BCD_DUMMY
	DEC	M6675_CONTADOR_BIN_BCD		;disminuye contador
	BRNE M6675_BBCDX_2				;si el contador llega a cero

	;RECUPERA VALORES DE ENTRADA Y REGISTROS AUXILIARES
	POP M6675_AUXILIAR_BIN_BCD
	POP M6675_CONTADOR_BIN_BCD
	POP TEMP_MAX6675_HIGH
	POP TEMP_MAX6675_LOW

RET								;Termina subrutina

M6675_BBCDX_2:

	LDI		R30,M6675_DIRECCION_BCD_2+1	;Z POINTS TO RESULT MSB + 1

M6675_BBCDX_3:

	LD		M6675_AUXILIAR_BIN_BCD,-Z		;GET (Z) WITH PRE-DECREMENT
	SUBI	M6675_AUXILIAR_BIN_BCD,-$03	;ADD 0X03
	SBRC	M6675_AUXILIAR_BIN_BCD,3		;IF BIT 3 NOT CLEAR
	ST		Z,M6675_AUXILIAR_BIN_BCD		;	STORE BACK
	LD		M6675_AUXILIAR_BIN_BCD,Z		;GET (Z)
	SUBI	M6675_AUXILIAR_BIN_BCD,-$30	;ADD 0X30
	SBRC	M6675_AUXILIAR_BIN_BCD,7		;IF BIT 7 NOT CLEAR
	ST		Z,M6675_AUXILIAR_BIN_BCD		;	STORE BACK
	CPI		ZL,M6675_DIRECCION_BCD_0		;DONE ALL THREE?
	BRNE	M6675_BBCDX_3					;LOOP AGAIN IF NOT
	RJMP	M6675_BBCDX_1		

	;RECUPERA VALORES DE ENTRADA Y REGISTROS AUXILIARES
	POP M6675_AUXILIAR_BIN_BCD
	POP M6675_CONTADOR_BIN_BCD
	POP TEMP_MAX6675_HIGH
	POP TEMP_MAX6675_LOW

RET




